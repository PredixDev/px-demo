<link rel="import" href="../polymer/polymer.html"/>
<link rel="import" href="../px-dropdown/px-dropdown.html"/>
<link rel="import" href="../px-typeahead/px-typeahead.html"/>
<link rel="import" href="../px-toggle/px-toggle.html"/>
<link rel="import" href="../px-app-helpers/object-assign-polyfill/object-assign-polyfill.html"/>
<link rel="import" href="css/px-demo-styles.html"/>

<!--
Creates inputs for editable demo props. Updates prop values when new configs
are applied.

##### Usage

    <px-demo-props></px-demo-props>

@element px-demo-props
@blurb Creates inputs for configuration props.
@homepage index.html
@demo index.html
-->

<dom-module id="px-demo-props">
  <template>
    <style include="px-demo-styles">
      :host {
        width: 100%;
      }
    </style>
      <template is="dom-if" if="{{_fields.length}}">
        <p class="epsilon u-mb+">Properties</p>

        <template is="dom-repeat" items="{{_fields}}" filter="[[_getVisibleFilter(_visibleProps)]]">

          <!-- INPUT: 'toggle'  -->
          <template is="dom-if" if="{{_itIs(item.inputType, 'toggle')}}">
            <div class="flex flex--justify u-mb-">
              <div class="label" aria-hidden="true">{{_getFieldLabel(item)}}</div>
              <div class="u-ml-">
                <px-toggle id="toggle-{{item.prop}}" size="small" checked$="[[_getValueForProp(item.prop, _values)]]" prop="{{item.prop}}" disabled$="{{_itIsTrue(item.inputDisabled)}}" data-debounce="{{item.inputDebounce}}" on-checked-changed="_handleToggleInput"></px-toggle>
              </div>
            </div>
            <template is="dom-if" if="{{item.inputHelpText}}">
              <p class="zeta demo-props__helper-text">{{item.inputHelpText}}</p>
            </template>
          </template>

          <!-- INPUT: 'text'  -->
          <template is="dom-if" if="{{_itIs(item.inputType, 'text')}}">
            <div class="u-mb-">
              <label for$="text-{{item.prop}}">{{_getFieldLabel(item)}}</label>
              <input id="text-{{item.prop}}" class="text-input u-mb--" type="text" placeholder="{{_getFieldPlaceholder(item)}}" disabled$="{{_itIsTrue(item.inputDisabled)}}" value="[[_getValueForProp(item.prop, _values)]]" prop="{{item.prop}}" data-debounce="{{item.inputDebounce}}" on-input="_handleTextInput" />
            </div>
            <template is="dom-if" if="{{item.inputHelpText}}">
              <p class="zeta demo-props__helper-text">{{item.inputHelpText}}</p>
            </template>
          </template>

          <!-- INPUT: 'number'  -->
          <template is="dom-if" if="{{_itIs(item.inputType, 'number')}}">
            <div class="u-mb-">
              <label for$="text-{{item.prop}}">{{_getFieldLabel(item)}}</label>
              <input id="text-{{item.prop}}" class="text-input u-mb--" type="number" placeholder="{{_getFieldPlaceholder(item)}}" disabled$="{{_itIsTrue(item.inputDisabled)}}" value="[[_getValueForProp(item.prop, _values)]]" prop="{{item.prop}}" data-debounce="{{item.inputDebounce}}" on-input="_handleNumberInput" />
            </div>
            <template is="dom-if" if="{{item.inputHelpText}}">
              <p class="zeta demo-props__helper-text">{{item.inputHelpText}}</p>
            </template>
          </template>

          <!-- INPUT: 'dropdown'  -->
          <template is="dom-if" if="{{_itIs(item.inputType, 'dropdown')}}">
            <div class="u-mb-">
              <label for$="dropdown-{{item.prop}}">{{_getFieldLabel(item)}}</label>
              <div class="u-mb--">
                <px-dropdown style="width: 100%;" id="dropdown-{{item.prop}}" prop="{{item.prop}}" data-debounce="{{item.inputDebounce}}" items="{{item.inputChoices}}" select-by="val" selected="[[_getValueForProp(item.prop, _values)]]" on-px-dropdown-selection-changed="_handleDropdownInput" disable-clear>
                </px-dropdown>
              </div>
            </div>
            <template is="dom-if" if="{{item.inputHelpText}}">
              <p class="zeta demo-props__helper-text--dropdown">{{item.inputHelpText}}</p>
            </template>
          </template>

          <!-- INPUT: 'typeahead'  -->
          <template is="dom-if" if="{{_itIs(item.inputType, 'typeahead')}}">
            <div class="u-mb-">
              <label for$="typeahead-{{item.prop}}">{{_getFieldLabel(item)}}</label>
              <div style="width: 100%;" class="u-mb--">
                <px-typeahead
                  id="typeahead-{{item.prop}}"
                  local-candidates="{{item.inputLocalCandidates}}"
                  prefetch-url="{{item.inputPrefetchUrl}}"
                  placeholder="[[item.inputPlaceholder]]"
                  input-value="[[_getValueForProp(item.prop, _values)]]"
                  prop="{{item.prop}}"
                  data-debounce="{{item.inputDebounce}}"
                  on-px-typeahead-item-selected="_handleTypeaheadItemSelected">
                </px-typeahead>
              </div>
            </div>
            <template is="dom-if" if="{{item.inputHelpText}}">
              <p class="zeta demo-props__helper-text--dropdown">{{item.inputHelpText}}</p>
            </template>
          </template>

          <!-- INPUT: 'javascriptCode'  -->
          <template is="dom-if" if="{{_itIsOneOf(item.inputType, 'code:EvaluatedJavaScript', 'code:JSON')}}">
            <div class="u-mb-">
              <label for$="text-{{item.prop}}">{{_getFieldLabel(item)}}</label>
              <div class="flex flex--row">
                <input id="text-{{item.prop}}" class="text-input flex__item u-mb--" type="text" placeholder="{{item.inputPlaceholder}}" value="{...}" prop="{{item.prop}}" on-input="_editComplexJSON" disabled />
                <button class="btn u-ml-" type="button" prop="{{item.prop}}" input-type="{{item.inputType}}" data-debounce="{{item.inputDebounce}}" on-tap="_handleCodeEditButton">Edit</button>
              </div>
            </div>
            <template is="dom-if" if="{{item.inputHelpText}}">
              <p class="zeta demo-props__helper-text">{{item.inputHelpText}}</p>
            </template>
          </template>

      </template>
    </template>
  </template>
</dom-module>

<script>
  Polymer({
    is: 'px-demo-props',

    properties: {
      /**
       * An object with keys describing the name of a possible input, the expected
       * return value type, the choices, and the input to show.
       */
      props: {
        type: Array,
        notify: true
      },

      /**
       * The currently chosen config. When this property is updated, any
       * props defined in the config will be updated in the fields.
       */
      config: {
        type: Object,
        observer: '_configChanged'
      },

      /**
       * Set to `true` if any props are visible.
       * Indicates if any props are currently visible.
       */
      propsVisible: {
        type: Boolean,
        value: true,
        notify: true,
        readOnly: true,
        observer: '_handlePropsVisibleChange'
      },

      /**
       * An array of field names to be mounted in the DOM.
       */
      _fields: {
        type: Array,
        computed: '_getFields(props)'
      },

      /**
       * Values to show for each property field.
       */
      _values: {
        type: Object,
        computed: '_getValues(_defaultValues, _configValues, _userValues)'
      },

      _defaultValues: {
        type: Object,
        computed: '_getDefaultValues(props)'
      },

      _configValues: {
        type: Object,
        computed: '_getConfigValues(config)'
      },

      _userValues: {
        type: Object,
        value: () => ({})
      },

      _visibleProps: {
        type: Array,
        computed: '_getVisibleProps(config, _fields)'
      },

      _isAttached: Boolean
    },

    observers: [
      '_valuesChanged(_values, props, _isAttached)'
    ],

    created() {
      // Used to keep track of whether toggles have reported their initial
      // falsey value. We ignore the first value to prevent value jitter.
      this._initializedToggles = new WeakSet();
    },

    attached() {
      Polymer.RenderStatus.afterNextRender(this, () => {
        this._isAttached = true;
      });
    },

    _valuesChanged(newValues, isAttached) {
      if (newValues && this.props && this._isAttached) {
        const updates = [];
        const propNames = Object.keys(newValues);
        for (let i=0; i<propNames.length; i++) {
          let propName = propNames[i];
          if (this.props.hasOwnProperty(propName) && newValues[propName] !== undefined && this.props[propName].value !== newValues[propName]) {
            updates.push([propName, newValues[propName]]);
          }
        }

        if (window.PxDemoDebug && updates.length) {
          console.log('[px-demo-props#_valuesChanged] Updating values:');
          updates.forEach(([p,v]) => console.log(`-- ${p}: ${JSON.stringify(v)}`));
        }

        while (updates.length) {
          let [propName, newValue] = updates.shift();
          this.set(`props.${propName}.value`, newValue);
        }
      }
    },

    _configChanged(newValue) {
      if (window.PxDemoDebug) {
        console.log('[px-demo-props#_configChanged] Config changed:');
        console.log(newValue);
      }
    },

    _getVisibleFilter(visible) {
      return function({prop}) {
        return visible.indexOf(prop) > -1;
      }
    },

    _getValueForProp(name, values) {
      if (name && values && values.hasOwnProperty(name)) {
        return values[name];
      }
    },

    _getValues(defaults, config, user) {
      if (typeof defaults === 'object' && typeof config === 'object' && typeof user === 'object') {
        return Object.assign({}, defaults, config, user);
      }
    },

    _getDefaultValues(props) {
      if (props) {
        const propNames = Object.keys(props);
        return propNames.reduce((values, propName) => {
          values[propName] = props[propName].defaultValue || props[propName].value;
          return values;
        }, {});
      }
    },

    _getConfigValues(config) {
      if (config) {
        // Special values to avoid:
        // - `configName`
        // - `configShowProps`
        // - `configHideProps`
        const reserved = /(configName|configHideProps|configShowProps|configReset)/;
        const propNames = Object.keys(config);
        return propNames.reduce((values, propName) => {
          if (!reserved.test(propName)) {
            values[propName] = config[propName];
          };
          return values;
        }, {})
      }
    },

    _getFields(props) {
      if (props) {
        const propNames = Object.keys(props);
        return propNames.map(propName => Object.assign(
          {},
          { prop: propName },
          props[propName]
        ));
      }
    },

    /**
     * Returns the public name for the prop that should be shown to the user
     *
     * @param {string} field - The key of the property in the `props` object
     * @return {string}
     */
    _getFieldLabel(field) {
      return field.inputLabel || this._formatInputLabel(field.prop);
    },

    /**
     * Converts a camel-case string like 'isReallyNice' to a regular string
     * like 'Is Really Nice'.
     *
     * @param {string} camelString
     * @return {string}
     */
    _formatInputLabel(camelString) {
      // First step converts 'isReallyNice' to 'is Really Nice'
      let camelToWords = camelString.replace(/([A-Z]+)/g, " $1").replace(/([A-Z][a-z])/g, " $1");
      // Second step converts 'is Really Nice' to 'Is Really Nice'
      return camelToWords.charAt(0).toUpperCase() + camelToWords.slice(1);
    },

    /**
     * Convenience method for comparing two references in a dom-if template.
     *
     * @return {boolean}
     */
    _itIs(it1, it2) {
      return it1 === it2;
    },

    /**
     * Convenience method for checking if a references in a dom-if template
     * exists in an array.
     *
     * @return {boolean}
     */
    _itIsOneOf(it) {
      // Slice off the end of args to check if any of them equal `it`
      var shouldBeOneOf = Array.prototype.slice.call(arguments, 1);
      // Iterate over args to see if `it` is equal to one of them
      var itIsInArray = false;
      var len = (shouldBeOneOf && Array.isArray(shouldBeOneOf)) ? shouldBeOneOf.length : 0;
      for (var i = 0; i < len; i++) {
        if (shouldBeOneOf[i] === it) itIsInArray = true;
      }
      return itIsInArray;
    },

    /**
     * Convenience method for checking if a reference in a dom-if is true.
     *
     * @return {boolean}
     */
    _itIsTrue(it) {
      if (typeof it === 'boolean') return it === true;
      if (it === 'true') return true;
      if (it === 'false') return false;
      return;
    },

    /**
     * Returns the `field.inputPlaceholder` or an empty string if placeholder
     * is not defined.
     *
     * @param {Object} field
     * @return {String}
     */
    _getFieldPlaceholder(field) {
      return field.inputPlaceholder || '';
    },

    /**
     * Binds a text input event to the prop.value it should change.
     */
    _handleTextInput(evt) {
      this._syncToProp(evt.target.prop, evt.target.value, evt.target.dataDebounce);
    },

   /**
    * Binds a text input event to the prop.value it should change.
    */
    _handleNumberInput(evt) {
      this._syncToProp(evt.target.prop, Number(evt.target.value), evt.target.dataDebounce);
    },

    /**
     * Binds a toggle input event to the prop.value it should change.
     */
    _handleToggleInput(evt) {
      if (!this._initializedToggles.has(evt.target)) {
        this._initializedToggles.add(evt.target);
        return;
      }
      this._syncToProp(evt.target.prop, evt.detail.value, evt.target.dataDebounce);
    },

    /**
     * Binds a dropdown input event to the prop.value it should change.
     */
    _handleDropdownInput(evt) {
        this._syncToProp(evt.target.prop, evt.detail.val, evt.target.dataDebounce);
    },

    /**
     * Binds a typeahead selected event to the prop.value it should change.
     */
    _handleTypeaheadItemSelected(evt) {
      this._syncToProp(evt.target.prop, evt.detail, evt.target.dataDebounce);
    },

    /**
     * Binds to a click on a code edit button.
     */
    _handleCodeEditButton(evt) {
      const {prop, type, value, inputType, inputLabel} = evt.model.item;
      const label = this._formatInputLabel(inputLabel || prop);

      this.fire('px-demo-props-code-edit-request', {
        value: value,
        mode: inputType,
        title: `Property Editor: ${label}`,
        save: (newValue) => {
          this._syncToProp(prop, newValue);
        }
      });
    },

    /**
     * Sync a value from a field to a prop.
     *
     * @param {string} propName - Name of prop, will also be its key in `props` object
     * @param {*} newVal - The updated value to set for the prop
     * @param {?number} debounceValue - Amount of time to debounce the prop change
     */
    _syncToProp(propName, newVal, debounceValue) {
      if (window.PxDemoDebug) {
        console.log('[px-demo-props#_syncToProp] Input changed:');
        console.log(`-- ${propName}: ${JSON.stringify(newVal)}`);
      }
      if (debounceValue) {
        this.debounce(`sync-prop-${propName}`, function() {
          this.set('props.' + propName + '.value', newVal);
        }, debounceValue);
      }
      else {
        this.set('props.' + propName + '.value', newVal);
      }
    },

    _getVisibleProps(config, fields) {
      if (config && fields) {
        if (Array.isArray(config.configShowProps)) {
          return config.configShowProps.slice(0);
        }
        if (Array.isArray(config.configHideProps)) {
          return fields.map(f => f.prop).filter(p => config.configHideProps.indexOf(p) === -1);
        }
        return fields.map(f => f.prop);
      }
    },

    /**
     * When the `propsVisible` attribute is updated, send a manual notification
     * out to the world.
     *
     * @param {Boolean} newVal - New `propsVisible` val
     * @param {Boolean} oldVal - Previous `propsVisible` value
     */
    _handlePropsVisibleChange: function(newVal, oldVal) {
      if (typeof newVal === 'boolean' && newVal !== oldVal) {
        if (newVal) {
          this.fire('px-demo-props-some-visible');
        }
        else {
          this.fire('px-demo-props-none-visible');
        }
      }

    },
    /**
     * Fires when no props are visible and the props container should be hidden.
     * @event px-demo-props-none-visible
     */
    /**
     * Fires when one or more props are visible and the props container should
     * be shown.
     * @event px-demo-props-some-visible
     */
  });
</script>
